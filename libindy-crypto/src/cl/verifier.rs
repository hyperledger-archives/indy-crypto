use bn::BigNumber;
use cl::*;
use cl::constants::{LARGE_E_START_VALUE, ITERATION};
use cl::helpers::*;
use errors::IndyCryptoError;

use std::collections::HashSet;
use std::iter::FromIterator;

/// Party that wants to check that prover has some credentials provided by issuer.
pub struct Verifier {}

impl Verifier {
    /// Creates and returns sub proof request entity builder.
    /// Part of proof request related to a particular schema-key.
    ///
    /// The purpose of sub proof request builder is building of sub proof request entity that
    /// represents requested attributes and predicates.
    ///
    /// # Example
    /// ```
    /// use indy_crypto::cl::verifier::Verifier;
    ///
    /// let mut sub_proof_request_builder = Verifier::new_sub_proof_request_builder().unwrap();
    /// sub_proof_request_builder.add_revealed_attr("name").unwrap();
    /// sub_proof_request_builder.add_predicate("age", "GE", 18).unwrap();
    /// let _sub_proof_request = sub_proof_request_builder.finalize().unwrap();
    /// ```
    pub fn new_sub_proof_request_builder() -> Result<SubProofRequestBuilder, IndyCryptoError> {
        let res = SubProofRequestBuilder::new()?;
        Ok(res)
    }

    /// Creates and returns proof verifier.
    ///
    /// The purpose of `proof verifier` is check proof provided by Prover.
    ///
    /// # Example
    /// ```
    /// use indy_crypto::cl::verifier::Verifier;
    ///
    /// let _proof_verifier = Verifier::new_proof_verifier().unwrap();
    /// ```
    pub fn new_proof_verifier() -> Result<ProofVerifier, IndyCryptoError> {
        Ok(ProofVerifier {
            credentials: Vec::new(),
        })
    }
}


#[derive(Debug)]
pub struct ProofVerifier {
    credentials: Vec<VerifiableCredential>,
}

impl ProofVerifier {
    /// Add sub proof request to proof verifier.
    /// The order of sub-proofs is important: both Prover and Verifier should use the same order.
    ///
    /// # Arguments
    /// * `proof_verifier` - Proof verifier.
    /// * `credential_schema` - Credential schema.
    /// * `credential_pub_key` - Credential public key.
    /// * `rev_reg_pub` - Revocation registry public key.
    /// * `sub_proof_request` - Requested attributes and predicates instance pointer.
    ///
    /// #Example
    /// ```
    /// use indy_crypto::cl::issuer::Issuer;
    /// use indy_crypto::cl::verifier::Verifier;
    ///
    /// let mut credential_schema_builder = Issuer::new_credential_schema_builder().unwrap();
    /// credential_schema_builder.add_attr("sex").unwrap();
    /// let credential_schema = credential_schema_builder.finalize().unwrap();
    ///
    /// let (credential_pub_key, _credential_priv_key, _credential_key_correctness_proof) = Issuer::new_credential_def(&credential_schema, false).unwrap();
    ///
    /// let mut sub_proof_request_builder = Verifier::new_sub_proof_request_builder().unwrap();
    /// sub_proof_request_builder.add_revealed_attr("sex").unwrap();
    /// let sub_proof_request = sub_proof_request_builder.finalize().unwrap();
    ///
    /// let mut proof_verifier = Verifier::new_proof_verifier().unwrap();
    ///
    /// proof_verifier.add_sub_proof_request(&sub_proof_request,
    ///                                      &credential_schema,
    ///                                      &credential_pub_key,
    ///                                      None,
    ///                                      None).unwrap();
    /// ```
    pub fn add_sub_proof_request(&mut self,
                                 sub_proof_request: &SubProofRequest,
                                 credential_schema: &CredentialSchema,
                                 credential_pub_key: &CredentialPublicKey,
                                 rev_key_pub: Option<&RevocationKeyPublic>,
                                 rev_reg: Option<&RevocationRegistry>) -> Result<(), IndyCryptoError> {
        ProofVerifier::_check_add_sub_proof_request_params_consistency(sub_proof_request, credential_schema)?;

        self.credentials.push(VerifiableCredential {
            pub_key: credential_pub_key.clone()?,
            sub_proof_request: sub_proof_request.clone(),
            credential_schema: credential_schema.clone(),
            rev_key_pub: rev_key_pub.map(Clone::clone),
            rev_reg: rev_reg.map(Clone::clone)
        });
        Ok(())
    }

    /// Verifies proof.
    ///
    /// # Arguments
    /// * `proof_verifier` - Proof verifier.
    /// * `proof` - Proof generated by Prover.
    /// * `nonce` - Nonce.
    ///
    ///
    /// #Example
    /// ```
    /// use indy_crypto::cl::new_nonce;
    /// use indy_crypto::cl::issuer::Issuer;
    /// use indy_crypto::cl::prover::Prover;
    /// use indy_crypto::cl::verifier::Verifier;
    ///
    /// let mut credential_schema_builder = Issuer::new_credential_schema_builder().unwrap();
    /// credential_schema_builder.add_attr("sex").unwrap();
    /// let credential_schema = credential_schema_builder.finalize().unwrap();
    ///
    /// let (credential_pub_key, credential_priv_key, cred_key_correctness_proof) = Issuer::new_credential_def(&credential_schema, false).unwrap();
    ///
    /// let master_secret = Prover::new_master_secret().unwrap();
    /// let master_secret_blinding_nonce = new_nonce().unwrap();
    /// let (blinded_master_secret, master_secret_blinding_data, blinded_master_secret_correctness_proof) =
    ///     Prover::blind_master_secret(&credential_pub_key, &cred_key_correctness_proof, &master_secret, &master_secret_blinding_nonce).unwrap();
    ///
    /// let mut credential_values_builder = Issuer::new_credential_values_builder().unwrap();
    /// credential_values_builder.add_value("sex", "5944657099558967239210949258394887428692050081607692519917050011144233115103").unwrap();
    /// let credential_values = credential_values_builder.finalize().unwrap();
    ///
    /// let credential_issuance_nonce = new_nonce().unwrap();
    ///
    /// let (mut credential_signature, signature_correctness_proof) =
    ///     Issuer::sign_credential("CnEDk9HrMnmiHXEV1WFgbVCRteYnPqsJwrTdcZaNhFVW",
    ///                             &blinded_master_secret,
    ///                             &blinded_master_secret_correctness_proof,
    ///                             &master_secret_blinding_nonce,
    ///                             &credential_issuance_nonce,
    ///                             &credential_values,
    ///                             &credential_pub_key,
    ///                             &credential_priv_key).unwrap();
    ///
    /// Prover::process_credential_signature(&mut credential_signature,
    ///                                      &credential_values,
    ///                                      &signature_correctness_proof,
    ///                                      &master_secret_blinding_data,
    ///                                      &master_secret,
    ///                                      &credential_pub_key,
    ///                                      &credential_issuance_nonce,
    ///                                      None, None, None).unwrap();
    ///
    /// let mut sub_proof_request_builder = Verifier::new_sub_proof_request_builder().unwrap();
    /// sub_proof_request_builder.add_revealed_attr("sex").unwrap();
    /// let sub_proof_request = sub_proof_request_builder.finalize().unwrap();
    ///
    /// let mut proof_builder = Prover::new_proof_builder().unwrap();
    /// proof_builder.add_sub_proof_request(&sub_proof_request,
    ///                                     &credential_schema,
    ///                                     &credential_signature,
    ///                                     &credential_values,
    ///                                     &credential_pub_key,
    ///                                     None,
    ///                                     None).unwrap();
    ///
    /// let proof_request_nonce = new_nonce().unwrap();
    /// let proof = proof_builder.finalize(&proof_request_nonce, &master_secret).unwrap();
    ///
    /// let mut proof_verifier = Verifier::new_proof_verifier().unwrap();
    ///
    /// proof_verifier.add_sub_proof_request(&sub_proof_request,
    ///                                      &credential_schema,
    ///                                      &credential_pub_key,
    ///                                      None,
    ///                                      None).unwrap();
    /// assert!(proof_verifier.verify(&proof, &proof_request_nonce).unwrap());
    /// ```
    pub fn verify(self,
                  proof: &Proof,
                  nonce: &Nonce) -> Result<bool, IndyCryptoError> {
        trace!("ProofVerifier::verify: >>> proof: {:?}, nonce: {:?}", proof, nonce);

        ProofVerifier::_check_verify_params_consistency(&self.credentials, proof)?;

        let mut tau_list: Vec<Vec<u8>> = Vec::new();

        assert_eq!(proof.proofs.len(), self.credentials.len()); //FIXME return error
        for idx in 0..proof.proofs.len() {
            let proof_item = &proof.proofs[idx];
            let credential = &self.credentials[idx];
            if let (Some(non_revocation_proof), Some(cred_rev_pub_key), Some(rev_reg), Some(rev_key_pub)) = (proof_item.non_revoc_proof.as_ref(),
                                                                                                             credential.pub_key.r_key.as_ref(),
                                                                                                             credential.rev_reg.as_ref(),
                                                                                                             credential.rev_key_pub.as_ref()) {
                tau_list.extend_from_slice(
                    &ProofVerifier::_verify_non_revocation_proof(&cred_rev_pub_key,
                                                                 &rev_reg,
                                                                 &rev_key_pub,
                                                                 &proof.aggregated_proof.c_hash,
                                                                 &non_revocation_proof)?.as_slice()?
                );
            };

            tau_list.append_vec(
                &ProofVerifier::_verify_primary_proof(&credential.pub_key.p_key,
                                                      &proof.aggregated_proof.c_hash,
                                                      &proof_item.primary_proof,
                                                      &credential.credential_schema,
                                                      &credential.sub_proof_request)?
            )?;
        }

        let mut values: Vec<Vec<u8>> = Vec::new();
        values.extend_from_slice(&tau_list);
        values.extend_from_slice(&proof.aggregated_proof.c_list);
        values.push(nonce.to_bytes()?);

        let c_hver = get_hash_as_int(&values)?;

        info!(target: "anoncreds_service", "Verifier verify proof -> done");

        let valid = c_hver == proof.aggregated_proof.c_hash;

        trace!("ProofVerifier::verify: <<< valid: {:?}", valid);

        Ok(valid)
    }

    fn _check_add_sub_proof_request_params_consistency(sub_proof_request: &SubProofRequest,
                                                       cred_schema: &CredentialSchema) -> Result<(), IndyCryptoError> {
        trace!("ProofVerifier::_check_add_sub_proof_request_params_consistency: >>> sub_proof_request: {:?}, cred_schema: {:?}", sub_proof_request, cred_schema);

        if sub_proof_request.revealed_attrs.difference(&cred_schema.attrs).count() != 0 {
            return Err(IndyCryptoError::InvalidStructure(format!("Credential doesn't contain requested attribute")));
        }

        let predicates_attrs =
            sub_proof_request.predicates.iter()
                .map(|predicate| predicate.attr_name.clone())
                .collect::<HashSet<String>>();

        if predicates_attrs.difference(&cred_schema.attrs).count() != 0 {
            return Err(IndyCryptoError::InvalidStructure(format!("Credential doesn't contain attribute requested in predicate")));
        }

        trace!("ProofVerifier::_check_add_sub_proof_request_params_consistency: <<<");

        Ok(())
    }

    fn _check_verify_params_consistency(credentials: &Vec<VerifiableCredential>,
                                        proof: &Proof) -> Result<(), IndyCryptoError> {
        trace!("ProofVerifier::_check_verify_params_consistency: >>> credentials: {:?}, proof: {:?}", credentials, proof);

        assert_eq!(proof.proofs.len(), credentials.len()); //FIXME return error
        for idx in 0..proof.proofs.len() {
            let proof_for_credential = &proof.proofs[idx];
            let credential = &credentials[idx];

            let proof_revealed_attrs = HashSet::from_iter(proof_for_credential.primary_proof.eq_proof.revealed_attrs.keys().cloned());

            if proof_revealed_attrs != credential.sub_proof_request.revealed_attrs {
                return Err(IndyCryptoError::AnoncredsProofRejected(format!("Proof revealed attributes not correspond to requested attributes")));
            }

            let proof_predicates =
                proof_for_credential.primary_proof.ge_proofs.iter()
                    .map(|ge_proof| ge_proof.predicate.clone())
                    .collect::<HashSet<Predicate>>();

            if proof_predicates != credential.sub_proof_request.predicates {
                return Err(IndyCryptoError::AnoncredsProofRejected(format!("Proof predicates not correspond to requested predicates")));
            }
        }

        trace!("ProofVerifier::_check_verify_params_consistency: <<<");

        Ok(())
    }

    fn _verify_primary_proof(p_pub_key: &CredentialPrimaryPublicKey,
                             c_hash: &BigNumber,
                             primary_proof: &PrimaryProof,
                             cred_schema: &CredentialSchema,
                             sub_proof_request: &SubProofRequest) -> Result<Vec<BigNumber>, IndyCryptoError> {
        trace!("ProofVerifier::_verify_primary_proof: >>> p_pub_key: {:?}, c_hash: {:?}, primary_proof: {:?}, cred_schema: {:?}, sub_proof_request: {:?}",
               p_pub_key, c_hash, primary_proof, cred_schema, sub_proof_request);

        let mut t_hat: Vec<BigNumber> = ProofVerifier::_verify_equality(p_pub_key,
                                                                        &primary_proof.eq_proof,
                                                                        c_hash,
                                                                        cred_schema,
                                                                        sub_proof_request)?;

        for ge_proof in primary_proof.ge_proofs.iter() {
            t_hat.append(&mut ProofVerifier::_verify_ge_predicate(p_pub_key, ge_proof, c_hash)?)
        }

        trace!("ProofVerifier::_verify_primary_proof: <<< t_hat: {:?}", t_hat);

        Ok(t_hat)
    }

    fn _verify_equality(p_pub_key: &CredentialPrimaryPublicKey,
                        proof: &PrimaryEqualProof,
                        c_hash: &BigNumber,
                        cred_schema: &CredentialSchema,
                        sub_proof_request: &SubProofRequest) -> Result<Vec<BigNumber>, IndyCryptoError> {
        trace!("ProofVerifier::_verify_equality: >>> p_pub_key: {:?}, proof: {:?}, c_hash: {:?}, cred_schema: {:?}, sub_proof_request: {:?}",
               p_pub_key, proof, c_hash, cred_schema, sub_proof_request);

        let unrevealed_attrs: HashSet<String> =
            cred_schema.attrs
                .difference(&sub_proof_request.revealed_attrs)
                .cloned()
                .collect::<HashSet<String>>();

        let t1: BigNumber = calc_teq(&p_pub_key, &proof.a_prime, &proof.e, &proof.v, &proof.m, &proof.m1, &proof.m2, &unrevealed_attrs)?;

        let mut ctx = BigNumber::new_context()?;

        let mut rar = proof.a_prime.mod_exp(&LARGE_E_START_VALUE, &p_pub_key.n, Some(&mut ctx))?;

        for (attr, encoded_value) in &proof.revealed_attrs {
            let cur_r = p_pub_key.r.get(attr)
                .ok_or(IndyCryptoError::AnoncredsProofRejected(format!("Value by key '{}' not found in pk.r", attr)))?;

            rar = cur_r
                .mod_exp(encoded_value, &p_pub_key.n, Some(&mut ctx))?
                .mod_mul(&rar, &p_pub_key.n, Some(&mut ctx))?;
        }

        let t2: BigNumber = p_pub_key.z
            .mod_div(&rar, &p_pub_key.n)?
            .inverse(&p_pub_key.n, Some(&mut ctx))?
            .mod_exp(&c_hash, &p_pub_key.n, Some(&mut ctx))?;

        let t: BigNumber = t1.mod_mul(&t2, &p_pub_key.n, Some(&mut ctx))?;

        trace!("ProofVerifier::_verify_equality: <<< t: {:?}", t);

        Ok(vec![t])
    }

    fn _verify_ge_predicate(p_pub_key: &CredentialPrimaryPublicKey,
                            proof: &PrimaryPredicateGEProof,
                            c_hash: &BigNumber) -> Result<Vec<BigNumber>, IndyCryptoError> {
        trace!("ProofVerifier::_verify_ge_predicate: >>> p_pub_key: {:?}, proof: {:?}, c_hash: {:?}", p_pub_key, proof, c_hash);

        let mut ctx = BigNumber::new_context()?;
        let mut tau_list = calc_tge(&p_pub_key, &proof.u, &proof.r, &proof.mj,
                                    &proof.alpha, &proof.t)?;

        for i in 0..ITERATION {
            let cur_t = proof.t.get(&i.to_string())
                .ok_or(IndyCryptoError::AnoncredsProofRejected(format!("Value by key '{}' not found in proof.t", i)))?;

            tau_list[i] = cur_t
                .mod_exp(&c_hash, &p_pub_key.n, Some(&mut ctx))?
                .inverse(&p_pub_key.n, Some(&mut ctx))?
                .mod_mul(&tau_list[i], &p_pub_key.n, Some(&mut ctx))?;
        }

        let delta = proof.t.get("DELTA")
            .ok_or(IndyCryptoError::AnoncredsProofRejected(format!("Value by key '{}' not found in proof.t", "DELTA")))?;

        tau_list[ITERATION] = p_pub_key.z
            .mod_exp(
                &BigNumber::from_dec(&proof.predicate.value.to_string())?,
                &p_pub_key.n, Some(&mut ctx))?
            .mul(&delta, Some(&mut ctx))?
            .mod_exp(&c_hash, &p_pub_key.n, Some(&mut ctx))?
            .inverse(&p_pub_key.n, Some(&mut ctx))?
            .mod_mul(&tau_list[ITERATION], &p_pub_key.n, Some(&mut ctx))?;

        tau_list[ITERATION + 1] = delta
            .mod_exp(&c_hash, &p_pub_key.n, Some(&mut ctx))?
            .inverse(&p_pub_key.n, Some(&mut ctx))?
            .mod_mul(&tau_list[ITERATION + 1], &p_pub_key.n, Some(&mut ctx))?;

        trace!("ProofVerifier::_verify_ge_predicate: <<< tau_list: {:?},", tau_list);

        Ok(tau_list)
    }

    fn _verify_non_revocation_proof(r_pub_key: &CredentialRevocationPublicKey,
                                    rev_reg: &RevocationRegistry,
                                    rev_key_pub: &RevocationKeyPublic,
                                    c_hash: &BigNumber, proof: &NonRevocProof) -> Result<NonRevocProofTauList, IndyCryptoError> {
        trace!("ProofVerifier::_verify_non_revocation_proof: >>> r_pub_key: {:?}, rev_reg: {:?}, rev_key_pub: {:?}, c_hash: {:?}",
               r_pub_key, rev_reg, rev_key_pub, c_hash);

        let ch_num_z = bignum_to_group_element(&c_hash)?;

        let t_hat_expected_values = create_tau_list_expected_values(r_pub_key, rev_reg, rev_key_pub, &proof.c_list)?;
        let t_hat_calc_values = create_tau_list_values(&r_pub_key, rev_reg, &proof.x_list, &proof.c_list)?;


        let non_revoc_proof_tau_list = Ok(NonRevocProofTauList {
            t1: t_hat_expected_values.t1.mul(&ch_num_z)?.add(&t_hat_calc_values.t1)?,
            t2: t_hat_expected_values.t2.mul(&ch_num_z)?.add(&t_hat_calc_values.t2)?,
            t3: t_hat_expected_values.t3.pow(&ch_num_z)?.mul(&t_hat_calc_values.t3)?,
            t4: t_hat_expected_values.t4.pow(&ch_num_z)?.mul(&t_hat_calc_values.t4)?,
            t5: t_hat_expected_values.t5.mul(&ch_num_z)?.add(&t_hat_calc_values.t5)?,
            t6: t_hat_expected_values.t6.mul(&ch_num_z)?.add(&t_hat_calc_values.t6)?,
            t7: t_hat_expected_values.t7.pow(&ch_num_z)?.mul(&t_hat_calc_values.t7)?,
            t8: t_hat_expected_values.t8.pow(&ch_num_z)?.mul(&t_hat_calc_values.t8)?
        });

        trace!("ProofVerifier::_verify_non_revocation_proof: <<< non_revoc_proof_tau_list: {:?}", non_revoc_proof_tau_list);

        non_revoc_proof_tau_list
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use cl::prover;
    use cl::issuer;
    use cl::helpers::MockHelper;
    use cl::prover::mocks::*;

    #[test]
    fn sub_proof_request_builder_works() {
        let mut sub_proof_request_builder = Verifier::new_sub_proof_request_builder().unwrap();
        sub_proof_request_builder.add_revealed_attr("name").unwrap();
        sub_proof_request_builder.add_predicate("age", "GE", 18).unwrap();
        let sub_proof_request = sub_proof_request_builder.finalize().unwrap();

        assert!(sub_proof_request.revealed_attrs.contains("name"));
        assert!(sub_proof_request.predicates.contains(&predicate()));
    }

    #[test]
    fn verify_equlity_works() {
        MockHelper::inject();

        let proof = prover::mocks::eq_proof();
        let pk = issuer::mocks::credential_primary_public_key();
        let c_h = prover::mocks::aggregated_proof().c_hash;
        let credential_schema = issuer::mocks::credential_schema();

        let mut sub_proof_request_builder = SubProofRequestBuilder::new().unwrap();
        sub_proof_request_builder.add_revealed_attr("name").unwrap();
        let sub_proof_request = sub_proof_request_builder.finalize().unwrap();

        let res: Vec<BigNumber> = ProofVerifier::_verify_equality(&pk,
                                                                  &proof,
                                                                  &c_h,
                                                                  &credential_schema,
                                                                  &sub_proof_request).unwrap();

        assert_eq!("470277798936647794194137508650027054807831276239220146191458949121351184311969639631580559702933970552912303095727375950265654923875623180594\
        558665299892048138982396859640029658129512030388704439167478475160221494455551953673063030258718822817279006735194293497773060067370281511840103396353767\
        808614044637705536967856221460875980417091400088977261162548054308147891873470252909728127624040095798124308872126348111952360683970039064279610528839497\
        341870538378087520077094824293591595512332618492288609809662046470201539906503906862206952553561077690711950698394752353796436977670202082695314607303658\
        48679702777436593", res[0].to_dec().unwrap());
    }

    #[test]
    fn _verify_ge_predicate_works() {
        MockHelper::inject();

        let proof = prover::mocks::ge_proof();
        let c_h = prover::mocks::aggregated_proof().c_hash;
        let pk = issuer::mocks::credential_primary_public_key();

        let res = ProofVerifier::_verify_ge_predicate(&pk, &proof, &c_h);

        assert!(res.is_ok());
        let res_data = res.unwrap();

        assert_eq!("376910366785000888640907068892773445290856982028553183426096623244555347257778101747799882436148347403830024840429617795354387295127009257238001847697728551\
        176536093973115809374401318141110098900739722767845936624708107236876761676800627172399726564255634308382367493256717024633900449205720018609556512423317410372608366135\
        066533236820567062263706984223659166559990463804265095415860347492428279789699722395246760391390256022639741018088870083311929296796590769109958556654779529301996928547\
        78469439162325030246066895851569630345729938981633504514117558420480144828304421708923356898912192737390539479512879411139535", res_data[0].to_dec().unwrap());

        assert_eq!("376910366785000888640907068892773445290856982028553183426096623244555347257778101747799882436148347403830024840429617795354387295127009257238001847697728551\
        176536093973115809374401318141110098900739722767845936624708107236876761676800627172399726564255634308382367493256717024633900449205720018609556512423317410372608366135\
        066533236820567062263706984223659166559990463804265095415860347492428279789699722395246760391390256022639741018088870083311929296796590769109958556654779529301996928547\
        78469439162325030246066895851569630345729938981633504514117558420480144828304421708923356898912192737390539479512879411139535", res_data[4].to_dec().unwrap());

        assert_eq!("4706530486660795807594696126453392843593312253601667969008027865938669831613255990876876168574341472858634191430502533997053787371484591516484310077682156120\
        0343390749927996265246866447155790487554483555192805709960222015718787293872197230832464704800887153568636866026153126587657548580608446574507279965440247754859129693686\
        1864273991033137371106324132550175224820164581900030456410773386740196083471393997554706544523739752281900419801521207994038554809091738654313973079882387597672518908535\
        80982844825639097363091181044515877489450972963624109587697097258041963985607958610791800500711857115582406526050626576194", res_data[5].to_dec().unwrap());
    }
}
